<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Image'>/**
</span> * @class  	Image
 * @author  Flavio De Stefano &lt;flavio.destefano@caffeinalab.com&gt;
 * Image manipulation module
 *
 * Require `ti.imagefactory`
 *
 */

<span id='Image-property-config'>/**
</span> * @type {Object}
 */
var config = _.extend({}, Alloy.CFG.image);
exports.config = config;


<span id='Image-method-process'>/**
</span> * Process the image and output in memory or filesystem
 *
 * `blob` is required to process the image, or an error is thrown
 *
 * ## Resizing options
 *
 * If `size` is passed, the image will be thumbnailized in a square.
 *
 * If `width` is passed the image will be resized with the specified width maintaining the ratio.
 *
 * If `height` is passed the image will be resized with the specified height maintaining the ratio.
 *
 * If `width` and `height` are both passed, the image will be resized
 * stretching the image with the specified width and height.
 *
 * ## Optional parameters
 *
 * `quality`: to degrade the image
 *
 * ## Output options
 *
 * `filename`: output the blob in the filesystem and release memory blob
 *
 * `callback`: call the function passing the output blob or output file if the keyword `filename` is specified
 * A null object is passed in case of errors
 *
 * @param  {Object} opt The options, see the description above.
 */
function process(opt) {
	if (!opt.blob) {
		Ti.API.error(&quot;Image: Set a blob please&quot;);
		opt.callback();
		return;
	}

	var TiImageFactory = require(&#39;ti.imagefactory&#39;);
	var density = opt.retina ? require(&#39;device&#39;).getScreenDensity() : 1;
	var R = null;

	if (opt.size) {

		R = TiImageFactory.imageAsThumbnail(opt.blob, {
			size: opt.size*density,
		});

	} else if (opt.width || opt.height) {

		opt.width = opt.width || opt.height*(opt.blob.width/opt.blob.height);
		opt.height = opt.height ||  opt.width*(opt.blob.height/opt.blob.width);
		R = TiImageFactory.imageAsResized(opt.blob, {
			width: opt.width*density,
			height: opt.height*density
		});

	} else {
		R = opt.blob;
	}

	if (R) {

		if (opt.quality) {
			R = TiImageFactory.compress(R, +opt.quality);
		}

		if (opt.filename) {

			var file = Ti.Filesystem.getFile(require(&#39;util&#39;).getAppDataDirectory(), opt.filename);
			var result = file.write(R);
			R = null; // nullable ALL!

			if (result) {
				opt.callback(file);
			} else {
				Ti.API.error(&quot;Image: error writing file&quot;);
			 	opt.callback();
			}

		} else {
			opt.callback(R);
		}

	} else {
		opt.callback();
	}
}
exports.process = process;</pre>
</body>
</html>
